# DB Index

---

DB 에서 Index를 사용하는 이유는 검색의 성능을 높이기 위해 사용된다.   

> Index 단어의 뜻으로 알 수 있듯이 DB에 목차를 넣는 다는 것을 알 수 있습니다.   
> Index는 테이블 내 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성 될 수 있습니다.  
> 고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효육적인 순서 매김 동작에 대한 기초를 제공합니다.
## DB Index의 원리

![img.png](https://tecoble.techcourse.co.kr/static/3fefe92795945a21d1a62168feabd14b/05b00/db-index.png)

- **DB Index를 사용하지 않을 경우**   
        데이터의 위치를 특정 할 수 없으므로 테이블 전체를 탐색(Full Scan)을 진행한다.
- **DB Index를 사용 하는 경우**   
 ```sql
CREATE INDEX USER_COMPANY_INDEX ON USER(COMPANY_ID);
#2개 이상의 컬럼을 사용해서 인덱스를 생성할 수도 있다.
```
Index는 데이터의 주소값을 저장하는 별도의 특별한 자료 구조입니다.   
user 테이블 `COMPANY_ID` 컬럼에 대한 Index가 존재한다면, 예시 쿼리를 수행 할 때 테이블 전체를 탐색하지 않고 해당 Index를 바탕으로 원하는 데이터의 위치를 빠르게 검색합니다.   
Index는 테이블에 있는 하나 이상의 컬럼으로 생성이 가능합니다.

### 클러스터 인덱스

> 클러스터 : 군집   
>  1. 군집은 pk중심으로 인덱싱이 되어 b-tree로 데이터를 인덱싱되어 관리한다
>  2. 인덱스를 생성 할 때 마다 페이지 전체를 다시 정렬 한다.
>  3.  비클러스형 인덱스 보다 검색 속도는 더 빠르다. 하지만 데이터의 입력/수정/삭제는 느리다.
> 4. 클러스터 인덱스는 성능이 좋지만, 테이블에 한 개만 생성할 수 있다. 그래서 어느 열에 클러스터형 인덱스를 생성하느냐에 따라서 시스템의 성능이 달라질 수 있다.
![클러스트](https://t1.daumcdn.net/cfile/tistory/2716FA44512C6B9827)

### 비클러스터 인덱스

> 비클러스터 : 
> 1.  비 클러스터형 인덱스를 생성할 때는 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성한다.
> 2. 비 클러스터형 인덱스에서 인덱스 자체의 리프 페이지는 데이터가 아니라, 데이터가 위치하는 포인터(RID)다. 클러스터형 보다 검색 속도는 느리지만, 데이터의 입력/수정/삭제는 더 빠르다.
> 3. 비 클러스터형 인덱스는 여러 개 생성할 수 있다. 하지만, 함부로 남용할 경우에는 오히려 시스템 성능을 떨어뜨리는 결과를 가져온다.
![no-클러스트](https://t1.daumcdn.net/cfile/tistory/1123E744512C6B9914)

### 클러스터와 비클러스터가 같이 사용되는 경우

-> 비클러스터의 설정한 인덱스를 사용하면 클러스트의 인덱스와 연결되어 데이터 페이지위치를 찾아 클러스터 인덱스로 다시 찾음

결론 : 비클러스터의 루트 페이지가 생성되지 않고 클러스터의 루트 페이지와 연결되어 있음.

---
## Index 자료 구조

***DB Index***에 적합한 자료 구조로는 크게 Hash Table, B-Tree, B+Tree등이 있습니다.

### Hash Table

![hash](https://user-images.githubusercontent.com/56240505/133892261-f95fd474-7955-4f8f-81f8-457d71ac6324.png)

해시 테이블은 Key - Value로 이루어진 데이터를 저장하데 특화된 자료구조입니다.   
해시 테이블 내부에는 ***버켓*** 이란 배열이 존재합니다.   
해시 함수를 통해 Key를 고유한 해시 값으로 변환시키는데, 이를 버켓 배열의 인덱스로 사용하며 해당 인덱스에 Value를 저장합니다.   
Key 값으로 Value가 저장되어 있는 위치를 바로 산출할 수 있기 때문에, 해시 테이블의 평균 적인 시간 복잡도 O(1)입니다.   
하지만 해시 함수를 제대로 정의하지 않으면 해시 함수를 통해 산출한 해시 값이 중복되는 해시 충돌이 발생합니다. 너무 많은 해시 충돌이 발생하면 검색 성능이 하락해 시간 복잡도가 O(N)에 수렴할 수 있습니다.
   
특징
- 해시 함수는 Key가 조금이라도 다르면 완전히 다른 해시 값을 생성합니다. 이러한 해시 테이블을 사용하는 Index의 경우 WHERE 조건의 등호(=) 연산에는 효율이 좋음
- 부등호 연산(>, <)은 부적합합니다. 해시 테이블은 내부 데이터들이 정렬되어 있지 않아 탐색이 효율적이지 않습니다.

### B-tree

![B-tree](https://user-images.githubusercontent.com/56240505/133893917-705097ca-4f0b-4f6a-8540-435988282643.png)
![B-tree2](https://user-images.githubusercontent.com/56240505/133895971-588e05fd-a013-4a39-9e89-86efd1b4d5c5.png)

B-Tree란 자식 노드가 2개 이상인 트리를 의미합니다. 이진검색 트리처럼 각 Key의 왼쪽 자식은 항상 Key보다 작은 값을, 오른쪽 자식은 큰 값을 가집니다. B-Tree 기반의 DB Index는 특정 컬럼의 값(Key)에 해당하는 노드에 데이터의 위치(Value)를 저장합니다.

B-Tree의 Key-Value 값들은 항상 Key를 기준으로 오름차순 정렬입니다. 이로 인해 부등호 연산(>, <)에 대해 해시 테이블보다 효율적인 데이터 탐색이 가능합니다. 또한 B-Tree는 균형 트리(Balanced Tree)로서, 최상위 루트 노드에서 리프 노드까지의 거리가 모두 동일하기 때문에 평균 시간 복잡도는 O(logN)입니다.

단점
![b-tree](https://user-images.githubusercontent.com/56240505/133894623-ea20089e-8b18-49af-b361-6fae2223e6bb.png)
- Index가 적용된 테이블에 데이터 갱신(INSERT, UPDATE, DELETE)이 반복되다보면, 트리의 균형이 깨지면서 성능이 악화됩니다.

- 순차적인 순서로 트리가 만들어졌을 때 전부 순회해야되기 때문에 이점을 보완하여 B+tree로 발전 하였다.


### B+tree

![b+tree](https://user-images.githubusercontent.com/56240505/133894968-99fda4ba-a422-448c-a19d-fa8fc03fa364.png)

- 말단의 리프 노드에만 데이터의 위치(Value)를 관리합니다.
- 중간 브랜치 노드에 Value가 없어서 B-Tree보다 메모리를 덜 차지하는 만큼, 노드의 메모리에 더 많은 Key를 저장할 수 있습니다.
- 노드에 더 많은 Key를 저장하는 만큼 트리의 높이가 더 낮아집니다.
- 말단의 리프 노드들끼리는 LinkedList 구조로 서로를 참조하고 있습니다.

---
_## 고려 사항

인덱스는 Index는 항상 최신 상태로 정렬되기 위해, 데이터 갱신(INSERT, UPDATE, DELETE) 작업에 대해 추가적인 연산이 발생합니다.   

 ->그러므로 이유없는 인덱스는 성능 저하를 초래한다.

1. INSERT : 새로운 데이터에 대한 인덱스가 추가된다.
2. DELETE : 삭제하는 데이터의 인덱스를 제거한다.
3. UPDATE : 기존의 인덱스를 제거하고, 갱신된 데이터에 대해 인덱스를 추가한다

***삭제나 생성 수정이 이루어지면 트리에 균형을 맞추기위해 계산을 하기 때문에 검색이 주가 되는 기능에 사용하는 것이 유의미있는 효과를 볼 수 있다.***
---
참고 자료
- https://tecoble.techcourse.co.kr/post/2021-09-18-db-index/
- https://www.youtube.com/watch?v=edpYzFgHbqs
- youtube.com/watch?v=edpYzFgHbqs&list=RDCMUC-mOekGSesms0agFntnQang&start_radio=1&rv=edpYzFgHbqs&t=0
- https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree_

    